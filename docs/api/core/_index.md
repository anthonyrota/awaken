---
title: API Reference - Basics
---

<!-- Do not edit this file. It is automatically generated by a build script. -->

## <code>Disposable</code>

### <a name="disposable-function"></a><code>Disposable - Function</code>

#### Signature

<pre>function Disposable(onDispose?: () =&gt; void): <a href="#disposable-interface">Disposable</a>;</pre>

### <a name="disposable-interface"></a><code>Disposable - Interface</code>

#### Signature

<pre>interface Disposable </pre>

## <code>isDisposable</code>

#### Signature

<pre>function isDisposable(value: unknown): value is <a href="#disposable-interface">Disposable</a>;</pre>

Determines whether the given value is a <code>[Disposable](#disposable)</code>.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | <p>The value to check.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>value is [Disposable](#disposable-interface)</code> | <p>Whether the value is a Disposable.</p> |

#### Example

```ts
isDisposable(Sink(() => {})); // true.
isDisposable(Source(() => {})) // false.
isDisposable(Subject()); // true.
isDisposable(Disposable()); // true.
isDisposable({}); // false.
isDisposable(() => {}); // false.
isDisposable(null); // false.
```

#### See Also

- <p><code><a href="#issink">isSink</a></code></p>
- <p><code><a href="#issource">isSource</a></code></p>
- <p><code><a href="#issubject">isSubject</a></code></p>

## <code>DisposalError</code>

### <a name="disposalerror-interface"></a><code>DisposalError - Interface</code>

#### Signature

<pre>interface DisposalError extends DisposalErrorImplementation </pre>

### <a name="disposalerror-variable"></a><code>DisposalError - Variable</code>

#### Signature

<pre>var DisposalError: <a href="#disposalerrorconstructor">DisposalErrorConstructor</a></pre>

Thrown when at least one error is caught during the disposal of a disposable.

## <code>DisposalErrorConstructor</code>

#### Signature

<pre>interface DisposalErrorConstructor </pre>

## <code>DISPOSED</code>

#### Signature

<pre>var DISPOSED: <a href="#disposable-interface">Disposable</a></pre>

## <code>implDisposableMethods</code>

#### Signature

<pre>function implDisposableMethods&lt;T extends object&gt;(value: T, disposable: <a href="#disposable-interface">Disposable</a>): T &amp; <a href="#disposable-interface">Disposable</a>;</pre>

Implements the Disposable Interface onto the given value by copying the disposable methods &amp; properties from the given value to the given disposable.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>T</code> | <p>The value to implement the Disposable Interface on.</p> |
| disposable | <code>[Disposable](#disposable-interface)</code> |  |

#### Returns

| Type | Description |
| --- | --- |
| <code>T &amp; [Disposable](#disposable-interface)</code> | <p>The given value which has been mutated. In strict javascript this is unnecessary but here it is useful as the returned value will have the type <code>T &amp; Disposable</code></p> |

## <code>Event</code>

#### Signature

<pre>type Event&lt;T&gt; = <a href="#push-interface">Push</a>&lt;T&gt; | <a href="#throw-interface">Throw</a> | <a href="#end-interface">End</a>;</pre>

This is the base construct for distributing values\/messages. All things pushed and received to and from <code>[Sinks](#sink)</code> will be events. An event is an object which consists of a <code>type</code> field, which determines the type of the event. There are three types of events: <code>[Push](#push)</code>, <code>[Throw](#throw)</code> and <code>[End](#end)</code> events:

- A Push event represents the &quot;pushing&quot; of a value to a sink, and has a <code>value</code> field equal to the value the event is carrying.

- A Throw represents the &quot;throwing&quot; of an error, and has an <code>error</code> field equal to the error the event is carrying. After a Sink receives an Error event, it will be disposed and will not take any more events.

- An End event represents the &quot;end&quot; of a source, and has no additional properties. After a Sink receives an End event, it will be disposed and will not take any more events.

When determining an event's type, you should <b>always</b> use either <code>[PushType](#pushtype)</code>, <code>[ThrowType](#throwtype)</code> or <code>[EndType](#endtype)</code> directly instead of their constant number values.

#### Example

```ts
const sink = Sink<number>(event => {
    console.log(event.type); // Either `PushType`, `ThrowType` or `EndType`.
    if (event.type === PushType) {
        // In this case event.value this will be of type `number`.
        console.log('value:', event.value);
    } else if (event.type === ThrowType) {
        const error = event.error; // This is of type `unknown`.
        console.log('error', event.error);
    }
});
sink(Push(2)); // `${PushType}`, value: 2.
sink(Throw(new Error('...'))); // `${ThrowType}`, Error(...).
```

#### See Also

- <p><code><a href="#source">Source</a></code></p>
- <p><code><a href="#sink">Sink</a></code></p>

## <code>EventType</code>

#### Signature

<pre>type EventType = <a href="#pushtype-typealias">PushType</a> | <a href="#throwtype-typealias">ThrowType</a> | <a href="#endtype-typealias">EndType</a>;</pre>

## <code>Push</code>

### <a name="push-function"></a><code>Push - Function</code>

A Push event represents the &quot;pushing&quot; of a value to a <code>[Sink](#sink)</code>, and has a <code>value</code> field equal to the value the event is carrying.

#### Returns

The created Push event.

#### Example

```ts
const event = Push([1, 2, 3]);
console.log(event.type); // `${PushType}`.
console.log(event.value); // [1, 2, 3].
```

#### See Also

- <p><code><a href="#event">Event</a></code></p>

#### Signature

<pre>function Push&lt;T&gt;(): <a href="#push-interface">Push</a>&lt;undefined&gt;;</pre>

#### Signature

<pre>function Push&lt;T&gt;(value: T): <a href="#push-interface">Push</a>&lt;T&gt;;</pre>

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>T</code> | <p>The value to put in the returned event.</p> |

### <a name="push-interface"></a><code>Push - Interface</code>

#### Signature

<pre>interface Push&lt;T&gt; </pre>

## <code>PushType</code>

### <a name="pushtype-typealias"></a><code>PushType - Type Alias</code>

#### Signature

<pre>type PushType = 0;</pre>

### <a name="pushtype-variable"></a><code>PushType - Variable</code>

#### Signature

<pre>var PushType: <a href="#pushtype-typealias">PushType</a></pre>

## <code>Throw</code>

### <a name="throw-function"></a><code>Throw - Function</code>

#### Signature

<pre>function Throw(error: unknown): <a href="#throw-interface">Throw</a>;</pre>

A Throw represents the &quot;throwing&quot; of an error, and has an <code>error</code> field equal to the error the event is carrying. After a <code>[Sink](#sink)</code> receives an Error event, it will be disposed and will not take any more events.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| error | <code>unknown</code> | <p>The error to be thrown.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>[Throw](#throw-interface)</code> | <p>The created Throw event.</p> |

#### Example

```ts
const event = Throw(new Error(...));
console.log(event.type); // `${ThrowType}`.
console.log(event.value); // Error(...).
```

#### See Also

- <p><code><a href="#event">Event</a></code></p>

### <a name="throw-interface"></a><code>Throw - Interface</code>

#### Signature

<pre>interface Throw </pre>

## <code>ThrowType</code>

### <a name="throwtype-typealias"></a><code>ThrowType - Type Alias</code>

#### Signature

<pre>type ThrowType = 1;</pre>

### <a name="throwtype-variable"></a><code>ThrowType - Variable</code>

#### Signature

<pre>var ThrowType: <a href="#throwtype-typealias">ThrowType</a></pre>

## <code>End</code>

### <a name="end-interface"></a><code>End - Interface</code>

#### Signature

<pre>interface End </pre>

### <a name="end-variable"></a><code>End - Variable</code>

#### Signature

<pre>var End: <a href="#end-interface">End</a></pre>

An End event represents the &quot;end&quot; of a <code>[Source](#source)</code>, and has no additional properties. After a Sink receives an End event, it will be disposed and will not take any more events.

#### Example

```ts
function onEvent(event: Event<unknown>): void {
    console.log(event.type);
};
const sink = Sink(onEvent);
sink(End); // This disposes the sink, then calls `onEvent` above.
// Logs:
// `${EndType}`
```

#### See Also

- <p><code><a href="#event">Event</a></code></p>

## <code>EndType</code>

### <a name="endtype-typealias"></a><code>EndType - Type Alias</code>

#### Signature

<pre>type EndType = 2;</pre>

### <a name="endtype-variable"></a><code>EndType - Variable</code>

#### Signature

<pre>var EndType: <a href="#endtype-typealias">EndType</a></pre>

## <code>Sink</code>

### <a name="sink-function"></a><code>Sink - Function</code>

#### Signature

<pre>function Sink&lt;T&gt;(onEvent: (event: <a href="#event">Event</a>&lt;T&gt;) =&gt; void): <a href="#sink-interface">Sink</a>&lt;T&gt;;</pre>

A Sink is what a <code>[Source](#source)</code> subscribes to. All events emitted by the source will be passed to the sink that has been given to the source.

The shape of a Sink is a function which takes an <code>[Event](#event)</code> and distributes it to the <code>onEvent</code> function as described below. Sinks also implement the <code>[Disposable](#disposable)</code> construct, and has all of the methods of the Disposable type, and can be treated as a Disposable. This is important as the way to stop a sink \(and also unsubscribe the sources subscribed to the sink\) is to dispose the sink itself. This also means that the way to cleanup or cancel some process when a Sink stops taking values \(for example, when creating a custom Source\), is to add a child to the Sink \(as done on a disposable\), which will then be called when the Sink is disposed. An example of this cancellation ability is say, cancelling a http request.

The sink constructor takes an <code>onEvent</code> function, which is called every time an event is received. When a sink is disposed, it will stop taking values and will ignore all subsequent events received. As well as this, when the sink is active and when the event received is a ThrowEvent or an EndEvent, then the sink will be disposed and then <i>after</i> this the <code>onEvent</code> function will called with the given event. If the <code>onEvent</code> function throws upon receiving an event, then the sink will immediately be disposed and the error will be thrown asynchronously in a <code>setTimeout</code> with delay zero.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| onEvent | <code>\(event: [Event](#event)&lt;T&gt;\) =&gt; void</code> | <p>The callback for when an event is received.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>[Sink](#sink-interface)&lt;T&gt;</code> | <p>The created Sink.</p> |

#### Example

```ts
const sink = Sink<number>(event => {
    if (event.type === PushType) {
        console.log(event.value);
    } else if (event.type === EndType) {
        console.log('ended');
    }
});
sink(Push(1));
sink(Push(2));
sinK(End);
// Logs:
// 1
// 2
// ended
```

#### Example

```ts
const sink = Sink<number>(event => {
    console.log(event);
});
sink(Push(1));
sink(Throw(new Error('some error was caught')));
sink(Push(4)); // Ignored.
sink(End); // Ignored.
sink(Throw(...)); // Ignored.
// Logs:
// { type: PushType, value: 1 }
// { type: ThrowType, error: Error }
```

#### Example

```ts
const sink = Sink<number>(event => {
    if (event.type === PushType && event.value === 5) {
        // This means that the Sink will stop receiving values, and all
        // disposable children added to this Sink will be disposed, allowing
        // for cleanup, for example in sources subscribed to this Sink.
        sink.dispose();
    }
    console.log(event);
});
for (let i = 0; i < 1_000_000_000 && sink.active; i++) {
    // Because the loop above checks if `sink.active` is true at the start of
    // every iteration, the loop will be exited when i === 6 before the
    // following is called, meaning that the following will never be reached
    // when i > 5. This is important as we want to stop iterating after the
    // source is disposed, meaning it won't take any more values. This
    // optimization prevents us from iterating pointlessly one billion times,
    // and instead we only iterate six times, with the `sink.active` check
    // breaking the loop on the seventh iteration.
    sink(Push(i));
}
sink(End); // This is ignored.
// Logs:
// { type: PushType, value: 0 }
// { type: PushType, value: 1 }
// { type: PushType, value: 2 }
// { type: PushType, value: 3 }
// { type: PushType, value: 4 }
// { type: PushType, value: 5 }
// Note: The End event is ignored here, as the sink was disposed upon
// receiving the Push(5) event.
```

#### Example

```ts
function onEvent(event: Event<unknown>): void {
    console.log(event);
    if (event.type === PushType && event.value === 2) {
        throw new Error('I don\'t like the value two. Begone.');
    }
}
const sink = Sink<number>(onEvent);
for (let i = 0; i < 10 && sink.active; i++) {
    // When i === 2, after the event is logged above, `onEvent` will throw an
    // error. When this happens, the sink will catch the error and it will be
    // thrown asynchronously in a setTimeout. As well as this, the sink will
    // be disposed immediately, unsubscribing anything subscribed to it.
    // Because the loop above checks if `sink.active` is true at the start of
    // every iteration, the loop will be exited when i === 3 before the
    // following is called.
    sink(Push(i));
}
sink(End); // This is ignored.
// Logs:
// { type: PushType, value: 0 }
// { type: PushType, value: 1 }
// { type: PushType, value: 2 }
```

#### Example

```ts
import { Request, startRequest, cancelRequest } from './my-api.ts';

const sink = Sink(() => {});
// This is important as, in the case where the sink is disposed later
// (meaning it will no longer take events), the request should be cancelled.
// Note that in this case, cancelRequest will be called straight after the
// sink receives the End event, which happens after the request completes and
// the sink has already received a Push event with the result of the request.
// However, in this example it is presumed that the cancelRequest function
// will do nothing when given an already completed request.
sink.add(() => {
    cancelRequest(myRequest);
});
const myRequest = startRequest(result => {
    sink(Push(result)));
    sink(End);
});

// Alternatively, if `startRequest` takes a Disposable and will automatically
// cancel the request when the disposable is disposed, in a similar manner to
// `ScheduleFunction`, we can directly pass the sink to the `startRequest`
// function and the request will automatically be cancelled when the sink is
// disposed.
const sink = Sink(() => {});
startRequest(result => {
    sink(Push(result));
    sink(End)
}, sink);
```

#### Example

```ts
// In this example the source emits values 0..49.
const source = range(50);
const sink = Sink(event => {
    console.log(event);
    if (event.value === 3) {
        sink.dispose();
    }
})
source(sink);
// Logs:
// Push(0)
// Push(1)
// Push(2)
// Push(3)
```

#### See Also

- <p><code><a href="#disposable">Disposable</a></code></p>
- <p><code><a href="#event">Event</a></code></p>
- <p><code><a href="#source">Source</a></code></p>
- <p><code><a href="#subject">Subject</a></code></p>

### <a name="sink-interface"></a><code>Sink - Interface</code>

#### Signature

<pre>interface Sink&lt;T&gt; extends <a href="#disposable-interface">Disposable</a> </pre>

## <code>isSink</code>

#### Signature

<pre>function isSink(value: unknown): value is <a href="#sink-interface">Sink</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Sink](#sink)</code>.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | <p>The value to check.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>value is [Sink](#sink-interface)&lt;unknown&gt;</code> | <p>Whether the value is a Sink.</p> |

#### Example

```ts
isSink(Sink(() => {})); // true.
isSink(Source(() => {})) // false.
isSink(Subject()); // true.
isSink(Disposable()); // false.
isSink({}); // false.
isSink(() => {}); // false.
isSink(null); // false.
```

#### See Also

- <p><code><a href="#isdisposable">isDisposable</a></code></p>
- <p><code><a href="#issource">isSource</a></code></p>
- <p><code><a href="#issubject">isSubject</a></code></p>

## <code>Source</code>

### <a name="source-function"></a><code>Source - Function</code>

#### Signature

<pre>function Source&lt;T&gt;(produce: (sink: <a href="#sink-interface">Sink</a>&lt;T&gt;) =&gt; void): <a href="#source-interface">Source</a>&lt;T&gt;;</pre>

A Source is a function which can be subscribed to with a <code>[Sink](#sink)</code>. This construct is the basis of all reactive programming done with this library. Sources are by default essentially a lazy push-style stream\/observable which will produce new values every subscription. The &quot;lazy&quot; part can be thought of as follows:

```ts
function mySource(): void {
    return (sink: Sink<mySourceType>) => {
        const producer = Producer();
        // ...add subscriber to producer.
        producer.produce();
    }
}
```

Compared to a less lazy and more eager implementation:

```ts
function mySource(): void {
    const producer = Producer();
    producer.produce();
    return (sink: Sink<mySourceType>) => {
         // ...add subscriber to producer.
    }
}
```

The shape of a Source is a function which takes a Sink, which will be passed to the &quot;produce&quot; function given at the creation of the Source whose job is to fill up the Sink with values. When the Source is subscribed to, this produce function is called with the sink given to the source. The given produce function should stop trying to emit values to the subscribed sink when the subscribed sink is disposed, and should stop\/cleanup any ongoing side processes.

If the given \(subscribed\) sink is disposed \(meaning it will not take any more values\), then the given produce function will never be called and the sink will just be ignored. On the other hand, if the sink is active, then the given produce function will be called with the sink as the only parameter.

However, if the given produce function throws an error during initial execution, the error will be passed to the sink if it is active at the time of throwing \(it might not be active in the case where it is disposed inside the given produce function, and then <i>after</i> this the given produce function throws\), then the error will be passed to the sink as a Throw event, otherwise is will be asynchronously reported through a <code>setTimeout</code> with delay zero, similar to how Promises don't synchronously throw errors during construction. Because of this error handling behavior, it is <i>always</i> a good practice to wrap any functions called asynchronously after subscription in a try\/catch, then to pass the error on in a Throw event to the subscribed sink which can then handle it.

The implementation for Source is very basic, and can roughly be thought of as follows:

```ts
const Source = produce => sink => {
    if (sink.active) {
        try { produce(sink) }
        catch (error) {
            if (sink.active) sink(Throw(error));
            else setTimeout(() => { throw error })
        }
    }
}
```

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| produce | <code>\(sink: [Sink](#sink-interface)&lt;T&gt;\) =&gt; void</code> | <p>This will be called with the given sink each subscription. When the sink is disposed this function should stop trying to emit values, and should stop/cleanup any ongoing side processes</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>[Source](#source-interface)&lt;T&gt;</code> | <p>The created Source.</p> |

#### Example

```ts
// Creating a Source which synchronously produces values 0..50
const source = Source(sink => {
    // Note: It is guaranteed (at the start of execution of this function
    // at least) that the sink here is active.
    for (let i = 0; i <= 50 && sink.active; i++) {
        sink(Push(i));
    }
    // Even if the above loop breaks, and the sink is no longer active, it
    // will just ignore this End event, meaning there is no need to check
    // whether the sink is active for distributing singular events like this
    // at the end of execution.
    sink(End);
});
source(Sink(console.log));
source(Sink(console.log));
// Logs:
// Push(0)
// Push(1)
// ...
// Push(50)
// End
// Push(0)
// Push(1)
// ...
// Push(50)
// End
```

#### Example

```ts
// Creating a Factory function which creates a Source that emits all the
// values in the provided array at construction.
function fromArray<T>(array: ArrayLike<T>): Source<T> {
    return Source(sink => {
        for (let i = 0; i < array.length && sink.active; i++) {
            sink(Push(array[i]));
        }
        sink(End);
    });
}
const array = [1, 2];
fromArray(array)(Sink(console.log));
fromArray(array)(Sink(console.log));
// Logs:
// Push(1)
// Push(2)
// End
// Push(1)
// Push(2)
// End
```

#### Example

```ts
// Creating a Source that maps an external api into a reactive one.
import { MyExternalSubscriptionToken, myExternalApi } from './myExternalApi';
const source = Source(sink => {
    let subscriptionToken: { v: MyExternalSubscriptionToken } | undefined;
    sink.add(() => {
        if (subscriptionToken) {
             myExternalApi.cancel(subscriptionToken);
        }
    })
    // In this example myExternalApi may throw.
    try {
        subscriptionToken = myExternalApi.request((value, error) => {
            if (error) {
                sink(Throw(error));
                return;
            }
            sink(Push(value));
            sink(End);
        });
    } catch (error) {
        sink(Throw(error));
    }
});
```

#### See Also

- <p><code><a href="#disposable">Disposable</a></code></p>
- <p><code><a href="#event">Event</a></code></p>
- <p><code><a href="#sink">Sink</a></code></p>
- <p><code><a href="#subject">Subject</a></code></p>

### <a name="source-interface"></a><code>Source - Interface</code>

#### Signature

<pre>interface Source&lt;T&gt; </pre>

## <code>isSource</code>

#### Signature

<pre>function isSource(value: unknown): value is <a href="#sink-interface">Sink</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Source](#source)</code>.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | <p>The value to check.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>value is [Sink](#sink-interface)&lt;unknown&gt;</code> | <p>Whether the value is a Source.</p> |

#### Example

```ts
isSource(Sink(() => {})); // false.
isSource(Source(() => {})); // true.
isSource(Subject()); // true.
isSource(Disposable()); // false.
isSource({}); // false.
isSource(() => {}); // false.
isSource(null); // false.
```

#### See Also

- <p><code><a href="#isdisposable">isDisposable</a></code></p>
- <p><code><a href="#issink">isSink</a></code></p>
- <p><code><a href="#issubject">isSubject</a></code></p>

## <code>subscribe</code>

#### Signature

<pre>function subscribe&lt;T&gt;(sink?: <a href="#sink-interface">Sink</a>&lt;T&gt;): (source: <a href="#source-interface">Source</a>&lt;T&gt;) =&gt; void;</pre>

Higher order function which takes a sink, and returns another function which receives a source that will be subscribed to using the given sink. This is useful, for example, at the end of pipe calls in order to subscribe to the transformed source.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| sink | <code>[Sink](#sink-interface)&lt;T&gt;</code> | <p>The sink to be given to the received source.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>\(source: [Source](#source-interface)&lt;T&gt;\) =&gt; void</code> | <p>The higher order function which takes a source to subscribe to.</p> |

#### Example

```ts
import { DogPictures, myGetDogPictures } from './myApi.ts';
import { MyRequestTimeoutError } from './myRequestTimeoutError.ts';
import { myReportError } from './myReportError.ts'
import { myUpdateViewWithDogs } from './myUpdateViewWithDogs.ts'

const sink = Sink<DogPictures>(event => {
    if (event.type === ThrowType) {
        myReportError(event.error)
    } else if (event.type === EndType) {
        return;
    }
    myUpdateViewWithDogs(event.value)
});

pipe(
    myGetDogPictures(...),
    timeoutMs(5000, throwError(() => new MyRequestTimeoutError())),
    retry(3),
    subscribe(sink)
);
```

#### See Also

- <p><code><a href="#source">Source</a></code></p>
- <p><code><a href="#sink">Sink</a></code></p>

## <code>Operator</code>

#### Signature

<pre>interface Operator&lt;T, U&gt; </pre>

## <code>IdentityOperator</code>

#### Signature

<pre>interface IdentityOperator </pre>

## <code>pipe</code>

Calls the value accumulatively against all of the functions given left-to-right. The result of calling a function with the accumulated value will be given to the next function, and the result of the last function will be returned. If there are no functions given, the given value will be returned.

#### Returns

The result of accumulatively calling the given value against all of the functions given left-to-right.

#### Signature

<pre>function pipe&lt;T&gt;(x: T): T;</pre>

<pre>function pipe&lt;T, R&gt;(x: T, f1: (x: T) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, H, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, H, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R, ...funcs: Array&lt;(x: any) =&gt; any&gt;): R;</pre>

<pre>function pipe&lt;T&gt;(x: T, ...fns: ((x: T) =&gt; T)[]): T;</pre>

## <code>flow</code>

Combines all of the functions given into a single function. This function takes a value and will accumulatively call it against all of the given functions left-to-right. The result of calling a function with the accumulated value will be given to the next function, and the result of the last function will be returned. If there are no functions given, then the combined function will return the value passed to it.

#### Returns

A function which takes a value and will return the result of accumulatively calling the value against all of the functions given left-to-right.

#### Signature

<pre>function flow(): &lt;T&gt;(x: T) =&gt; T;</pre>

<pre>function flow&lt;T, R&gt;(f1: (x: T) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, H, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, H, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R, ...funcs: Array&lt;(x: any) =&gt; any&gt;): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T&gt;(...fns: Array&lt;(x: T) =&gt; T&gt;): (x: T) =&gt; T;</pre>

## <code>Subject</code>

### <a name="subject-function"></a><code>Subject - Function</code>

#### Signature

<pre>function Subject&lt;T&gt;(): <a href="#subject-interface">Subject</a>&lt;T&gt;;</pre>

### <a name="subject-interface"></a><code>Subject - Interface</code>

#### Signature

<pre>interface Subject&lt;T&gt; extends <a href="#source-interface">Source</a>&lt;T&gt;, <a href="#sink-interface">Sink</a>&lt;T&gt;, <a href="#nonmarkedsubject">NonMarkedSubject</a>&lt;T&gt; </pre>

## <code>isSubject</code>

#### Signature

<pre>function isSubject(value: unknown): value is <a href="#subject-interface">Subject</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Subject](#subject)</code>.

#### Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | <p>The value to check.</p> |

#### Returns

| Type | Description |
| --- | --- |
| <code>value is [Subject](#subject-interface)&lt;unknown&gt;</code> | <p>Whether the value is a Subject.</p> |

#### Example

```ts
isSubject(Sink(() => {})); // false.
isSubject(Source(() => {})) // false.
isSubject(Subject()); // true.
isSubject(Disposable()); // false.
isSubject({}); // false.
isSubject(() => {}); // false.
isSubject(null); // false.
```

#### See Also

- <p><code><a href="#isdisposable">isDisposable</a></code></p>
- <p><code><a href="#issink">isSink</a></code></p>
- <p><code><a href="#issource">isSource</a></code></p>

## <code>SubjectDistributionSinkDisposalError</code>

### <a name="subjectdistributionsinkdisposalerror-interface"></a><code>SubjectDistributionSinkDisposalError - Interface</code>

#### Signature

<pre>interface SubjectDistributionSinkDisposalError extends SubjectDistributionSinkDisposalErrorImplementation </pre>

### <a name="subjectdistributionsinkdisposalerror-variable"></a><code>SubjectDistributionSinkDisposalError - Variable</code>

#### Signature

<pre>var SubjectDistributionSinkDisposalError: <a href="#subjectdistributionsinkdisposalerrorconstructor">SubjectDistributionSinkDisposalErrorConstructor</a></pre>

Thrown when at least least one error is caught during the checking of whether a subscribed sink is active or not.

## <code>SubjectDistributionSinkDisposalErrorConstructor</code>

#### Signature

<pre>interface SubjectDistributionSinkDisposalErrorConstructor </pre>

## <code>markAsSubject</code>

#### Signature

<pre>function markAsSubject&lt;T&gt;(subjectFunction: <a href="#nonmarkedsubject">NonMarkedSubject</a>&lt;T&gt;): <a href="#subject-interface">Subject</a>&lt;T&gt;;</pre>

## <code>NonMarkedSubject</code>

#### Signature

<pre>interface NonMarkedSubject&lt;T&gt; extends <a href="#disposable-interface">Disposable</a> </pre>

## <code>ScheduleFunction</code>

#### Signature

<pre>interface ScheduleFunction&lt;T extends any[] = []&gt; </pre>
