> This file is automatically generated by a build script.<br>If you notice anything off, please feel free to open a new issue!

# API Reference - Basics

<details><summary><b>Table of Contents</b></summary><br>

1. [<code>Disposable</code>](#disposable) - [<code>Function</code>](#disposable-function), [<code>Interface</code>](#disposable-interface)
   1. [<code>isDisposable</code>](#isdisposable)
   2. [<code>DisposalError</code>](#disposalerror) - [<code>Interface</code>](#disposalerror-interface), [<code>Variable</code>](#disposalerror-variable)
   3. [<code>DisposalErrorConstructor</code>](#disposalerrorconstructor)
   4. [<code>DISPOSED</code>](#disposed)
   5. [<code>implDisposableMethods</code>](#impldisposablemethods)
2. [<code>Event</code>](#event)
   1. [<code>EventType</code>](#eventtype)
   2. [<code>Push</code>](#push) - [<code>Function</code>](#push-function), [<code>Interface</code>](#push-interface)
   3. [<code>PushType</code>](#pushtype) - [<code>Type</code>](#pushtype-typealias), [<code>Variable</code>](#pushtype-variable)
   4. [<code>Throw</code>](#throw) - [<code>Function</code>](#throw-function), [<code>Interface</code>](#throw-interface)
   5. [<code>ThrowType</code>](#throwtype) - [<code>Type</code>](#throwtype-typealias), [<code>Variable</code>](#throwtype-variable)
   6. [<code>End</code>](#end) - [<code>Interface</code>](#end-interface), [<code>Variable</code>](#end-variable)
   7. [<code>EndType</code>](#endtype) - [<code>Type</code>](#endtype-typealias), [<code>Variable</code>](#endtype-variable)
3. [<code>Sink</code>](#sink) - [<code>Function</code>](#sink-function), [<code>Interface</code>](#sink-interface)
   1. [<code>isSink</code>](#issink)
4. [<code>Source</code>](#source) - [<code>Function</code>](#source-function), [<code>Interface</code>](#source-interface)
   1. [<code>isSource</code>](#issource)
   2. [<code>subscribe</code>](#subscribe)
5. [<code>Operator</code>](#operator)
   1. [<code>IdentityOperator</code>](#identityoperator)
   2. [<code>pipe</code>](#pipe)
   3. [<code>flow</code>](#flow)
6. [<code>Subject</code>](#subject) - [<code>Function</code>](#subject-function), [<code>Interface</code>](#subject-interface)
   1. [<code>isSubject</code>](#issubject)
   2. [<code>SubjectDistributionSinkDisposalError</code>](#subjectdistributionsinkdisposalerror) - [<code>Interface</code>](#subjectdistributionsinkdisposalerror-interface), [<code>Variable</code>](#subjectdistributionsinkdisposalerror-variable)
   3. [<code>SubjectDistributionSinkDisposalErrorConstructor</code>](#subjectdistributionsinkdisposalerrorconstructor)
   4. [<code>markAsSubject</code>](#markassubject)
   5. [<code>NonMarkedSubject</code>](#nonmarkedsubject)
7. [<code>ScheduleFunction</code>](#schedulefunction)</details>

## <code>Disposable</code>

### <a name="disposable-function"></a><code>Disposable - Function</code>

<b>Signature</b>

<pre>function Disposable(onDispose?: () =&gt; void): <a href="#disposable-interface">Disposable</a>;</pre>

### <a name="disposable-interface"></a><code>Disposable - Interface</code>

<b>Signature</b>

<pre>interface Disposable </pre>

## <code>isDisposable</code>

<b>Signature</b>

<pre>function isDisposable(value: unknown): value is <a href="#disposable-interface">Disposable</a>;</pre>

Determines whether the given value is a <code>[Disposable](#disposable)</code>.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | The value to check. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>value is [Disposable](#disposable-interface)</code> | Whether the value is a Disposable. |

<b>Example Usage</b>

```ts
isDisposable(Sink(() => {})); // true.
isDisposable(Source(() => {})) // false.
isDisposable(Subject()); // true.
isDisposable(Disposable()); // true.
isDisposable({}); // false.
isDisposable(() => {}); // false.
isDisposable(null); // false.
```

<b>See Also</b>

- <code>[isSink](#issink)</code>
- <code>[isSource](#issource)</code>
- <code>[isSubject](#issubject)</code>

## <code>DisposalError</code>

### <a name="disposalerror-interface"></a><code>DisposalError - Interface</code>

<b>Signature</b>

<pre>interface DisposalError extends DisposalErrorImplementation </pre>

### <a name="disposalerror-variable"></a><code>DisposalError - Variable</code>

<b>Signature</b>

<pre>var DisposalError: <a href="#disposalerrorconstructor">DisposalErrorConstructor</a></pre>

Thrown when at least one error is caught during the disposal of a disposable.

## <code>DisposalErrorConstructor</code>

<b>Signature</b>

<pre>interface DisposalErrorConstructor </pre>

## <code>DISPOSED</code>

<b>Signature</b>

<pre>var DISPOSED: <a href="#disposable-interface">Disposable</a></pre>

## <code>implDisposableMethods</code>

<b>Signature</b>

<pre>function implDisposableMethods&lt;T extends object&gt;(value: T, disposable: <a href="#disposable-interface">Disposable</a>): T & <a href="#disposable-interface">Disposable</a>;</pre>

Implements the Disposable Interface onto the given value by copying the disposable methods & properties from the given value to the given disposable.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>T</code> | The value to implement the Disposable Interface on. |
| disposable | <code>[Disposable](#disposable-interface)</code> |  |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>T & [Disposable](#disposable-interface)</code> | The given value which has been mutated. In strict javascript this is unnecessary but here it is useful as the returned value will have the type <code>T & Disposable</code> |

## <code>Event</code>

<b>Signature</b>

<pre>type Event&lt;T&gt; = <a href="#push-interface">Push</a>&lt;T&gt; | <a href="#throw-interface">Throw</a> | <a href="#end-interface">End</a>;</pre>

This is the base construct for distributing values\/messages. All things pushed and received to and from <code>[Sinks](#sink)</code> will be events. An event is an object which consists of a <code>type</code> field, which determines the type of the event. There are three types of events: <code>[Push](#push)</code>, <code>[Throw](#throw)</code> and <code>[End](#end)</code> events:

- A Push event represents the &quot;pushing&quot; of a value to a sink, and has a <code>value</code> field equal to the value the event is carrying.

- A Throw represents the &quot;throwing&quot; of an error, and has an <code>error</code> field equal to the error the event is carrying. After a Sink receives an Error event, it will be disposed and will not take any more events.

- An End event represents the &quot;end&quot; of a source, and has no additional properties. After a Sink receives an End event, it will be disposed and will not take any more events.

When determining an event's type, you should <b>always</b> use either <code>[PushType](#pushtype)</code>, <code>[ThrowType](#throwtype)</code> or <code>[EndType](#endtype)</code> directly instead of their constant number values.

<b>Example Usage</b>

```ts
const sink = Sink<number>(event => {
    console.log(event.type); // Either `PushType`, `ThrowType` or `EndType`.
    if (event.type === PushType) {
        // In this case event.value this will be of type `number`.
        console.log('value:', event.value);
    } else if (event.type === ThrowType) {
        const error = event.error; // This is of type `unknown`.
        console.log('error', event.error);
    }
});
sink(Push(2)); // `${PushType}`, value: 2.
sink(Throw(new Error('...'))); // `${ThrowType}`, Error(...).
```

<b>See Also</b>

- <code>[Source](#source)</code>
- <code>[Sink](#sink)</code>

## <code>EventType</code>

<b>Signature</b>

<pre>type EventType = <a href="#pushtype-typealias">PushType</a> | <a href="#throwtype-typealias">ThrowType</a> | <a href="#endtype-typealias">EndType</a>;</pre>

## <code>Push</code>

### <a name="push-function"></a><code>Push - Function</code>

A Push event represents the &quot;pushing&quot; of a value to a <code>[Sink](#sink)</code>, and has a <code>value</code> field equal to the value the event is carrying.

<b>Returns</b>

The created Push event.

<b>Example Usage</b>

```ts
const event = Push([1, 2, 3]);
console.log(event.type); // `${PushType}`.
console.log(event.value); // [1, 2, 3].
```

<b>See Also</b>

- <code>[Event](#event)</code>

<b>Signature</b>

<pre>function Push&lt;T&gt;(): <a href="#push-interface">Push</a>&lt;undefined&gt;;</pre>

<b>Signature</b>

<pre>function Push&lt;T&gt;(value: T): <a href="#push-interface">Push</a>&lt;T&gt;;</pre>

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>T</code> | The value to put in the returned event. |

### <a name="push-interface"></a><code>Push - Interface</code>

<b>Signature</b>

<pre>interface Push&lt;T&gt; </pre>

## <code>PushType</code>

### <a name="pushtype-typealias"></a><code>PushType - Type</code>

<b>Signature</b>

<pre>type PushType = 0;</pre>

### <a name="pushtype-variable"></a><code>PushType - Variable</code>

<b>Signature</b>

<pre>var PushType: <a href="#pushtype-typealias">PushType</a></pre>

## <code>Throw</code>

### <a name="throw-function"></a><code>Throw - Function</code>

<b>Signature</b>

<pre>function Throw(error: unknown): <a href="#throw-interface">Throw</a>;</pre>

A Throw represents the &quot;throwing&quot; of an error, and has an <code>error</code> field equal to the error the event is carrying. After a <code>[Sink](#sink)</code> receives an Error event, it will be disposed and will not take any more events.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| error | <code>unknown</code> | The error to be thrown. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>[Throw](#throw-interface)</code> | The created Throw event. |

<b>Example Usage</b>

```ts
const event = Throw(new Error(...));
console.log(event.type); // `${ThrowType}`.
console.log(event.value); // Error(...).
```

<b>See Also</b>

- <code>[Event](#event)</code>

### <a name="throw-interface"></a><code>Throw - Interface</code>

<b>Signature</b>

<pre>interface Throw </pre>

## <code>ThrowType</code>

### <a name="throwtype-typealias"></a><code>ThrowType - Type</code>

<b>Signature</b>

<pre>type ThrowType = 1;</pre>

### <a name="throwtype-variable"></a><code>ThrowType - Variable</code>

<b>Signature</b>

<pre>var ThrowType: <a href="#throwtype-typealias">ThrowType</a></pre>

## <code>End</code>

### <a name="end-interface"></a><code>End - Interface</code>

<b>Signature</b>

<pre>interface End </pre>

### <a name="end-variable"></a><code>End - Variable</code>

<b>Signature</b>

<pre>var End: <a href="#end-interface">End</a></pre>

An End event represents the &quot;end&quot; of a <code>[Source](#source)</code>, and has no additional properties. After a Sink receives an End event, it will be disposed and will not take any more events.

<b>Example Usage</b>

```ts
function onEvent(event: Event<unknown>): void {
    console.log(event.type);
};
const sink = Sink(onEvent);
sink(End); // This disposes the sink, then calls `onEvent` above.
// Logs:
// `${EndType}`
```

<b>See Also</b>

- <code>[Event](#event)</code>

## <code>EndType</code>

### <a name="endtype-typealias"></a><code>EndType - Type</code>

<b>Signature</b>

<pre>type EndType = 2;</pre>

### <a name="endtype-variable"></a><code>EndType - Variable</code>

<b>Signature</b>

<pre>var EndType: <a href="#endtype-typealias">EndType</a></pre>

## <code>Sink</code>

### <a name="sink-function"></a><code>Sink - Function</code>

<b>Signature</b>

<pre>function Sink&lt;T&gt;(onEvent: (event: <a href="#event">Event</a>&lt;T&gt;) =&gt; void): <a href="#sink-interface">Sink</a>&lt;T&gt;;</pre>

A Sink is what a <code>[Source](#source)</code> subscribes to. All events emitted by the source will be passed to the sink that has been given to the source.

The shape of a Sink is a function which takes an <code>[Event](#event)</code> and distributes it to the <code>onEvent</code> function as described below. Sinks also implement the <code>[Disposable](#disposable)</code> construct, and has all of the methods of the Disposable type, and can be treated as a Disposable. This is important as the way to stop a sink \(and also unsubscribe the sources subscribed to the sink\) is to dispose the sink itself. This also means that the way to cleanup or cancel some process when a Sink stops taking values \(for example, when creating a custom Source\), is to add a child to the Sink \(as done on a disposable\), which will then be called when the Sink is disposed. An example of this cancellation ability is say, cancelling a http request.

The sink constructor takes an <code>onEvent</code> function, which is called every time an event is received. When a sink is disposed, it will stop taking values and will ignore all subsequent events received. As well as this, when the sink is active and when the event received is a ThrowEvent or an EndEvent, then the sink will be disposed and then <i>after</i> this the <code>onEvent</code> function will called with the given event. If the <code>onEvent</code> function throws upon receiving an event, then the sink will immediately be disposed and the error will be thrown asynchronously in a <code>setTimeout</code> with delay zero.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| onEvent | <code>\(event: [Event](#event)&lt;T&gt;\) =&gt; void</code> | The callback for when an event is received. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>[Sink](#sink-interface)&lt;T&gt;</code> | The created Sink. |

<b>Example Usage</b>

```ts
// In this example the source emits values 0..49.
const source = range(50);
const sink = Sink(event => {
    console.log(event);
    if (event.value === 3) {
        sink.dispose();
    }
})
// Subscribe the source to the sink so that it produces values and sends them
// to the sink.
source(sink);
// Logs:
// Push(0)
// Push(1)
// Push(2)
// Push(3)
```

<b>Example Usage</b>

```ts
// Passing a sink a throw event.
const sink = Sink<number>(event => {
    console.log(event);
});
sink(Push(1));
sink(Throw(new Error('some error was caught')));
sink(Push(4)); // Ignored.
sink(End); // Ignored.
sink(Throw(...)); // Ignored.
// Logs:
// { type: PushType, value: 1 }
// { type: ThrowType, error: Error }
```

<b>See Also</b>

- <code>[Disposable](#disposable)</code>
- <code>[Event](#event)</code>
- <code>[Source](#source)</code>
- <code>[Subject](#subject)</code>

### <a name="sink-interface"></a><code>Sink - Interface</code>

<b>Signature</b>

<pre>interface Sink&lt;T&gt; extends <a href="#disposable-interface">Disposable</a> </pre>

## <code>isSink</code>

<b>Signature</b>

<pre>function isSink(value: unknown): value is <a href="#source-interface">Source</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Sink](#sink)</code>.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | The value to check. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>value is [Source](#source-interface)&lt;unknown&gt;</code> | Whether the value is a Sink. |

<b>Example Usage</b>

```ts
isSink(Sink(() => {})); // true.
isSink(Source(() => {})) // false.
isSink(Subject()); // true.
isSink(Disposable()); // false.
isSink({}); // false.
isSink(() => {}); // false.
isSink(null); // false.
```

<b>See Also</b>

- <code>[isDisposable](#isdisposable)</code>
- <code>[isSource](#issource)</code>
- <code>[isSubject](#issubject)</code>

## <code>Source</code>

### <a name="source-function"></a><code>Source - Function</code>

<b>Signature</b>

<pre>function Source&lt;T&gt;(produce: (sink: <a href="#sink-interface">Sink</a>&lt;T&gt;) =&gt; void): <a href="#source-interface">Source</a>&lt;T&gt;;</pre>

A Source is a function which can be subscribed to with a <code>[Sink](#sink)</code>. This construct is the basis of all reactive programming done with this library. Sources are by default essentially a lazy push-style stream\/observable which will produce new values every subscription. The &quot;lazy&quot; part can be thought of as follows:

```ts
function mySource(): void {
    return (sink: Sink<mySourceType>) => {
        const producer = Producer();
        // ...add subscriber to producer.
        producer.produce();
    }
}
```

Compared to a less lazy and more eager implementation:

```ts
function mySource(): void {
    const producer = Producer();
    producer.produce();
    return (sink: Sink<mySourceType>) => {
         // ...add subscriber to producer.
    }
}
```

The shape of a Source is a function which takes a Sink, which will be passed to the &quot;produce&quot; function given at the creation of the Source whose job is to fill up the Sink with values. When the Source is subscribed to, this produce function is called with the sink given to the source. The given produce function should stop trying to emit values to the subscribed sink when the subscribed sink is disposed, and should stop\/cleanup any ongoing side processes.

If the given \(subscribed\) sink is disposed \(meaning it will not take any more values\), then the given produce function will never be called and the sink will just be ignored. On the other hand, if the sink is active, then the given produce function will be called with the sink as the only parameter.

However, if the given produce function throws an error during initial execution, the error will be passed to the sink if it is active at the time of throwing \(it might not be active in the case where it is disposed inside the given produce function, and then <i>after</i> this the given produce function throws\), then the error will be passed to the sink as a Throw event, otherwise is will be asynchronously reported through a <code>setTimeout</code> with delay zero, similar to how Promises don't synchronously throw errors during construction. Because of this error handling behavior, it is <i>always</i> a good practice to wrap any functions called asynchronously after subscription in a try\/catch, then to pass the error on in a Throw event to the subscribed sink which can then handle it.

The implementation for Source is very basic, and can roughly be thought of as follows:

```ts
const Source = produce => sink => {
    if (sink.active) {
        try { produce(sink) }
        catch (error) {
            if (sink.active) sink(Throw(error));
            else setTimeout(() => { throw error })
        }
    }
}
```

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| produce | <code>\(sink: [Sink](#sink-interface)&lt;T&gt;\) =&gt; void</code> | This will be called with the given sink each subscription. When the sink is disposed this function should stop trying to emit values, and should stop\/cleanup any ongoing side processes |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>[Source](#source-interface)&lt;T&gt;</code> | The created Source. |

<b>Example Usage</b>

```ts
// Creating a Source which synchronously produces values 0..50
const source = Source(sink => {
    // Note: It is guaranteed (at the start of execution of this function
    // at least) that the sink here is active.
    for (let i = 0; i <= 50 && sink.active; i++) {
        sink(Push(i));
    }
    // Even if the above loop breaks, and the sink is no longer active, it
    // will just ignore this End event, meaning there is no need to check
    // whether the sink is active for distributing singular events like this
    // at the end of execution.
    sink(End);
});
source(Sink(console.log));
source(Sink(console.log));
// Logs:
// Push(0)
// Push(1)
// ...
// Push(50)
// End
// Push(0)
// Push(1)
// ...
// Push(50)
// End
```

<b>Example Usage</b>

```ts
// Creating a Source that maps an external api into a reactive one.
import { MyExternalSubscriptionToken, myExternalApi } from './myExternalApi';
const source = Source(sink => {
    let subscriptionToken: { v: MyExternalSubscriptionToken } | undefined;
    sink.add(() => {
        if (subscriptionToken) {
             myExternalApi.cancel(subscriptionToken);
        }
    })
    // In this example myExternalApi may throw.
    try {
        subscriptionToken = myExternalApi.request((value, error) => {
            if (error) {
                sink(Throw(error));
                return;
            }
            sink(Push(value));
            sink(End);
        });
    } catch (error) {
        sink(Throw(error));
    }
});
```

<b>See Also</b>

- <code>[Disposable](#disposable)</code>
- <code>[Event](#event)</code>
- <code>[Sink](#sink)</code>
- <code>[Subject](#subject)</code>

### <a name="source-interface"></a><code>Source - Interface</code>

<b>Signature</b>

<pre>interface Source&lt;T&gt; </pre>

## <code>isSource</code>

<b>Signature</b>

<pre>function isSource(value: unknown): value is <a href="#sink-interface">Sink</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Source](#source)</code>.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | The value to check. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>value is [Sink](#sink-interface)&lt;unknown&gt;</code> | Whether the value is a Source. |

<b>Example Usage</b>

```ts
isSource(Sink(() => {})); // false.
isSource(Source(() => {})); // true.
isSource(Subject()); // true.
isSource(Disposable()); // false.
isSource({}); // false.
isSource(() => {}); // false.
isSource(null); // false.
```

<b>See Also</b>

- <code>[isDisposable](#isdisposable)</code>
- <code>[isSink](#issink)</code>
- <code>[isSubject](#issubject)</code>

## <code>subscribe</code>

<b>Signature</b>

<pre>function subscribe&lt;T&gt;(sink?: <a href="#sink-interface">Sink</a>&lt;T&gt;): (source: <a href="#source-interface">Source</a>&lt;T&gt;) =&gt; void;</pre>

Higher order function which takes a sink, and returns another function which receives a source that will be subscribed to using the given sink. This is useful, for example, at the end of pipe calls in order to subscribe to the transformed source.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| sink | <code>[Sink](#sink-interface)&lt;T&gt;</code> | The sink to be given to the received source. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>\(source: [Source](#source-interface)&lt;T&gt;\) =&gt; void</code> | The higher order function which takes a source to subscribe to. |

<b>Example Usage</b>

```ts
import { DogPictures, myGetDogPictures } from './myApi.ts';
import { MyRequestTimeoutError } from './myRequestTimeoutError.ts';
import { myReportError } from './myReportError.ts'
import { myUpdateViewWithDogs } from './myUpdateViewWithDogs.ts'

const sink = Sink<DogPictures>(event => {
    if (event.type === ThrowType) {
        myReportError(event.error)
    } else if (event.type === EndType) {
        return;
    }
    myUpdateViewWithDogs(event.value)
});

pipe(
    myGetDogPictures(...),
    timeoutMs(5000, throwError(() => new MyRequestTimeoutError())),
    retry(3),
    subscribe(sink)
);
```

<b>See Also</b>

- <code>[Source](#source)</code>
- <code>[Sink](#sink)</code>

## <code>Operator</code>

<b>Signature</b>

<pre>interface Operator&lt;T, U&gt; </pre>

## <code>IdentityOperator</code>

<b>Signature</b>

<pre>interface IdentityOperator </pre>

## <code>pipe</code>

Calls the value accumulatively against all of the functions given left-to-right. The result of calling a function with the accumulated value will be given to the next function, and the result of the last function will be returned. If there are no functions given, the given value will be returned.

<b>Returns</b>

The result of accumulatively calling the given value against all of the functions given left-to-right.

<b>Signature</b>

<pre>function pipe&lt;T&gt;(x: T): T;</pre>

<pre>function pipe&lt;T, R&gt;(x: T, f1: (x: T) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, H, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R): R;</pre>

<pre>function pipe&lt;T, A, B, C, D, E, F, G, H, R&gt;(x: T, f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R, ...funcs: Array&lt;(x: any) =&gt; any&gt;): R;</pre>

<pre>function pipe&lt;T&gt;(x: T, ...fns: ((x: T) =&gt; T)[]): T;</pre>

## <code>flow</code>

Combines all of the functions given into a single function. This function takes a value and will accumulatively call it against all of the given functions left-to-right. The result of calling a function with the accumulated value will be given to the next function, and the result of the last function will be returned. If there are no functions given, then the combined function will return the value passed to it.

<b>Returns</b>

A function which takes a value and will return the result of accumulatively calling the value against all of the functions given left-to-right.

<b>Signature</b>

<pre>function flow(): &lt;T&gt;(x: T) =&gt; T;</pre>

<pre>function flow&lt;T, R&gt;(f1: (x: T) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, H, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T, A, B, C, D, E, F, G, H, R&gt;(f1: (x: T) =&gt; A, f2: (x: A) =&gt; B, f3: (x: B) =&gt; C, f4: (x: C) =&gt; D, f5: (x: D) =&gt; E, f6: (x: E) =&gt; F, f7: (x: F) =&gt; G, f8: (x: G) =&gt; H, f9: (x: H) =&gt; R, ...funcs: Array&lt;(x: any) =&gt; any&gt;): (x: T) =&gt; R;</pre>

<pre>function flow&lt;T&gt;(...fns: Array&lt;(x: T) =&gt; T&gt;): (x: T) =&gt; T;</pre>

## <code>Subject</code>

### <a name="subject-function"></a><code>Subject - Function</code>

<b>Signature</b>

<pre>function Subject&lt;T&gt;(): <a href="#subject-interface">Subject</a>&lt;T&gt;;</pre>

### <a name="subject-interface"></a><code>Subject - Interface</code>

<b>Signature</b>

<pre>interface Subject&lt;T&gt; extends <a href="#source-interface">Source</a>&lt;T&gt;, <a href="#sink-interface">Sink</a>&lt;T&gt;, <a href="#nonmarkedsubject">NonMarkedSubject</a>&lt;T&gt; </pre>

## <code>isSubject</code>

<b>Signature</b>

<pre>function isSubject(value: unknown): value is <a href="#subject-interface">Subject</a>&lt;unknown&gt;;</pre>

Determines whether the given value is a <code>[Subject](#subject)</code>.

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| value | <code>unknown</code> | The value to check. |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <code>value is [Subject](#subject-interface)&lt;unknown&gt;</code> | Whether the value is a Subject. |

<b>Example Usage</b>

```ts
isSubject(Sink(() => {})); // false.
isSubject(Source(() => {})) // false.
isSubject(Subject()); // true.
isSubject(Disposable()); // false.
isSubject({}); // false.
isSubject(() => {}); // false.
isSubject(null); // false.
```

<b>See Also</b>

- <code>[isDisposable](#isdisposable)</code>
- <code>[isSink](#issink)</code>
- <code>[isSource](#issource)</code>

## <code>SubjectDistributionSinkDisposalError</code>

### <a name="subjectdistributionsinkdisposalerror-interface"></a><code>SubjectDistributionSinkDisposalError - Interface</code>

<b>Signature</b>

<pre>interface SubjectDistributionSinkDisposalError extends SubjectDistributionSinkDisposalErrorImplementation </pre>

### <a name="subjectdistributionsinkdisposalerror-variable"></a><code>SubjectDistributionSinkDisposalError - Variable</code>

<b>Signature</b>

<pre>var SubjectDistributionSinkDisposalError: <a href="#subjectdistributionsinkdisposalerrorconstructor">SubjectDistributionSinkDisposalErrorConstructor</a></pre>

Thrown when at least least one error is caught during the checking of whether a subscribed sink is active or not.

## <code>SubjectDistributionSinkDisposalErrorConstructor</code>

<b>Signature</b>

<pre>interface SubjectDistributionSinkDisposalErrorConstructor </pre>

## <code>markAsSubject</code>

<b>Signature</b>

<pre>function markAsSubject&lt;T&gt;(subjectFunction: <a href="#nonmarkedsubject">NonMarkedSubject</a>&lt;T&gt;): <a href="#subject-interface">Subject</a>&lt;T&gt;;</pre>

## <code>NonMarkedSubject</code>

<b>Signature</b>

<pre>interface NonMarkedSubject&lt;T&gt; extends <a href="#disposable-interface">Disposable</a> </pre>

## <code>ScheduleFunction</code>

<b>Signature</b>

<pre>interface ScheduleFunction&lt;T extends any[] = []&gt; </pre>
