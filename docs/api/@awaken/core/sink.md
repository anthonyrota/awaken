<!-- Do not edit this file. It is automatically generated by a build script. -->

## `isSink`

Determines whether the given value is a Sink.

### Example

```ts
isSink(Sink(() => {})); // true.
isSink(Source(() => {})) // false.
isSink(Subject()); // true.
isSink(Disposable()); // false.
isSink({}); // false.
isSink(() => {}); // false.
isSink(null); // false.
```

### Signature

<pre>function isSink(value: unknown): value is <a href="#sink">Sink</a>&lt;unknown&gt;;</pre>

### See Also

<a href="#sink">Sink</a>

<a href="source.md#source">Source</a>

<a href="subject.md#subject">Subject</a>

<a href="disposable.md#disposable">Disposable</a>

<a href="disposable.md#isdisposable">isDisposable</a>

<a href="source.md#issource">isSource</a>

<a href="subject.md#issubject">isSubject</a>




## `Sink`

A Sink is what a <a href="source.md#source">Source</a> subscribes to. All events emitted by the source will be passed to the sink that has been given to the source.

The shape of a Sink is a function which takes an <a href="event.md#event">Event</a> and distributes it to the `onEvent` function as described below. Sinks also implement the <a href="disposable.md#disposable">Disposable</a> construct, and has all of the methods of the Disposable type, and can be treated as a Disposable. This is important as the way to stop a sink (and also unsubscribe the sources subscribed to the sink) is to dispose the sink itself. This also means that the way to cleanup or cancel some process when a Sink stops taking values (for example, when creating a custom Source), is to add a child to the Sink (as done on a disposable), which will then be called when the Sink is disposed. An example of this cancellation ability is say, cancelling a http request.

The sink constructor takes an `onEvent` function, which is called every time an event is received. When a sink is disposed, it will stop taking values and will ignore all subsequent events received. As well as this, when the sink is active and when the event received is a ThrowEvent or an EndEvent, then the sink will be disposed and then \*after\* this the `onEvent` function will called with the given event. If the `onEvent` function throws upon receiving an event, then the sink will immediately be disposed and the error will be thrown asynchronously in a `setTimeout` with delay zero.

### Example

```ts
const sink = Sink<number>(event => {
    if (event.type === PushType) {
        console.log(event.value);
    } else if (event.type === EndType) {
        console.log('ended');
    }
});
sink(Push(1));
sink(Push(2));
sinK(End);
// Logs:
// 1
// 2
// ended
```

### Example

```ts
const sink = Sink<number>(event => {
    console.log(event);
});
sink(Push(1));
sink(Throw(new Error('some error was caught')));
sink(Push(4)); // Ignored.
sink(End); // Ignored.
sink(Throw(...)); // Ignored.
// Logs:
// { type: PushType, value: 1 }
// { type: ThrowType, error: Error }
```

### Example

```ts
const sink = Sink<number>(event => {
    if (event.type === PushType && event.value === 5) {
        // This means that the Sink will stop receiving values, and all
        // disposable children added to this Sink will be disposed, allowing
        // for cleanup, for example in sources subscribed to this Sink.
        sink.dispose();
    }
    console.log(event);
});
for (let i = 0; i < 1_000_000_000 && sink.active; i++) {
    // Because the loop above checks if `sink.active` is true at the start of
    // every iteration, the loop will be exited when i === 6 before the
    // following is called, meaning that the following will never be reached
    // when i > 5. This is important as we want to stop iterating after the
    // source is disposed, meaning it won't take any more values. This
    // optimization prevents us from iterating pointlessly one billion times,
    // and instead we only iterate six times, with the `sink.active` check
    // breaking the loop on the seventh iteration.
    sink(Push(i));
}
sink(End); // This is ignored.
// Logs:
// { type: PushType, value: 0 }
// { type: PushType, value: 1 }
// { type: PushType, value: 2 }
// { type: PushType, value: 3 }
// { type: PushType, value: 4 }
// { type: PushType, value: 5 }
// Note: The End event is ignored here, as the sink was disposed upon
// receiving the Push(5) event.
```

### Example

```ts
function onEvent(event: Event<unknown>): void {
    console.log(event);
    if (event.type === PushType && event.value === 2) {
        throw new Error('I don\'t like the value two. Begone.');
    }
}
const sink = Sink<number>(onEvent);
for (let i = 0; i < 10 && sink.active; i++) {
    // When i === 2, after the event is logged above, `onEvent` will throw an
    // error. When this happens, the sink will catch the error and it will be
    // thrown asynchronously in a setTimeout. As well as this, the sink will
    // be disposed immediately, unsubscribing anything subscribed to it.
    // Because the loop above checks if `sink.active` is true at the start of
    // every iteration, the loop will be exited when i === 3 before the
    // following is called.
    sink(Push(i));
}
sink(End); // This is ignored.
// Logs:
// { type: PushType, value: 0 }
// { type: PushType, value: 1 }
// { type: PushType, value: 2 }
```

### Example

```ts
import { Request, startRequest, cancelRequest } from './my-api.ts';

const sink = Sink(() => {});
// This is important as, in the case where the sink is disposed later
// (meaning it will no longer take events), the request should be cancelled.
// Note that in this case, cancelRequest will be called straight after the
// sink receives the End event, which happens after the request completes and
// the sink has already received a Push event with the result of the request.
// However, in this example it is presumed that the cancelRequest function
// will do nothing when given an already completed request.
sink.add(() => {
    cancelRequest(myRequest);
});
const myRequest = startRequest(result => {
    sink(Push(result)));
    sink(End);
});

// Alternatively, if `startRequest` takes a Disposable and will automatically
// cancel the request when the disposable is disposed, in a similar manner to
// `ScheduleFunction`, we can directly pass the sink to the `startRequest`
// function and the request will automatically be cancelled when the sink is
// disposed.
const sink = Sink(() => {});
startRequest(result => {
    sink(Push(result));
    sink(End)
}, sink);
```

### Example

```ts
// In this example the source emits values 0..49.
const source = range(50);
const sink = Sink(event => {
    console.log(event);
    if (event.value === 3) {
        sink.dispose();
    }
})
source(sink);
// Logs:
// Push(0)
// Push(1)
// Push(2)
// Push(3)
```

### Signature

<pre>function Sink&lt;T&gt;(onEvent: (event: <a href="event.md#event">Event</a>&lt;T&gt;) =&gt; void): <a href="#sink">Sink</a>&lt;T&gt;;</pre>

### See Also

<a href="disposable.md#disposable">Disposable</a>

<a href="event.md#event">Event</a>

<a href="source.md#source">Source</a>

<a href="subject.md#subject">Subject</a>

<a href="util.md#asyncreporterror">asyncReportError</a>





### Signature

<pre>interface Sink&lt;T&gt; extends <a href="disposable.md#disposable">Disposable</a> </pre>



