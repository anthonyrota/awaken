> This file is automatically generated by a build script.<br>If you notice anything off, please feel free to open a new issue!

# Source

<details><summary><b>Table of Contents</b></summary>

1. [<code>Source</code>](#Source) - [<code>Function</code>](#Source-Function), [<code>Interface</code>](#Source-Interface)</details>

## <a name="Source"></a><code>Source</code>

A Source is a function which can be subscribed to with a <code>[Sink](02-Sink.md#Sink)</code>. This construct is the basis of all reactive programming done with this library. Sources are by default essentially a lazy push-style stream\/observable which will produce new values every subscription. The &quot;lazy&quot; part can be thought of as follows:

```ts
function mySource(): void {
    return (sink: Sink<mySourceType>) => {
        const producer = Producer();
        // ...add subscriber to producer.
        producer.produce();
    }
}
```

Compared to a less lazy and more eager implementation:

```ts
function mySource(): void {
    const producer = Producer();
    producer.produce();
    return (sink: Sink<mySourceType>) => {
         // ...add subscriber to producer.
    }
}
```

The shape of a Source is a function which takes a Sink, which will be passed to the &quot;produce&quot; function given at the creation of the Source whose job is to fill up the Sink with values. When the Source is subscribed to, this produce function is called with the sink given to the source. The given produce function should stop trying to emit values to the subscribed sink when the subscribed sink is disposed, and should stop\/cleanup any ongoing side processes.

If the given \(subscribed\) sink is disposed \(meaning it will not take any more values\), then the given produce function will never be called and the sink will just be ignored. On the other hand, if the sink is active, then the given produce function will be called with the sink as the only parameter.

However, if the given produce function throws an error during initial execution, the error will be passed to the sink if it is active at the time of throwing \(it might not be active in the case where it is disposed inside the given produce function, and then <i>after</i> this the given produce function throws\), then the error will be passed to the sink as a Throw event, otherwise is will be asynchronously reported through a <code>setTimeout</code> with delay zero, similar to how Promises don't synchronously throw errors during construction. Because of this error handling behavior, it is <i>always</i> a good practice to wrap any functions called asynchronously after subscription in a try\/catch, then to pass the error on in a Throw event to the subscribed sink which can then handle it.

The implementation for Source is very basic, and can roughly be thought of as follows:

```ts
const Source = produce => sink => {
    if (sink.active) {
        try { produce(sink) }
        catch (error) {
            if (sink.active) sink(Throw(error));
            else setTimeout(() => { throw error })
        }
    }
}
```

### <a name="Source-Function"></a><code>Source - Function</code>

<b>Signature - [source.ts#L506](..\/..\/packages\/core\/src\/source.ts#L506)</b>

<pre>function Source&lt;T&gt;(produce: (sink: <a href="02-Sink.md#Sink-Interface">Sink</a>&lt;T&gt;) =&gt; void): <a href="#Source-Interface">Source</a>&lt;T&gt;</pre>

<b>Parameters</b>

| Parameter | Type | Description |
| --- | --- | --- |
| produce | <pre>(sink: [Sink](02-Sink.md#Sink-Interface)&lt;T&gt;) =&gt; void</pre> | This will be called with the given sink each subscription. When the sink is disposed this function should stop trying to emit values, and should stop\/cleanup any ongoing side processes |

<b>Returns</b>

| Type | Description |
| --- | --- |
| <pre>[Source](#Source-Interface)&lt;T&gt;</pre> | The created Source. |

<b>Example Usage</b>

```ts
// Creating a Source which synchronously produces values 0..50
const source = Source(sink => {
    // Note: It is guaranteed (at the start of execution of this function
    // at least) that the sink here is active.
    for (let i = 0; i <= 50 && sink.active; i++) {
        sink(Push(i));
    }
    // Even if the above loop breaks, and the sink is no longer active, it
    // will just ignore this End event, meaning there is no need to check
    // whether the sink is active for distributing singular events like this
    // at the end of execution.
    sink(End);
});
source(Sink(console.log));
source(Sink(console.log));
// Logs:
// Push(0)
// Push(1)
// ...
// Push(50)
// End
// Push(0)
// Push(1)
// ...
// Push(50)
// End
```

<b>Example Usage</b>

```ts
// Creating a Source that maps an external api into a reactive one.
import { MyExternalSubscriptionToken, myExternalApi } from './myExternalApi';
const source = Source(sink => {
    let subscriptionToken: { v: MyExternalSubscriptionToken } | undefined;
    sink.add(() => {
        if (subscriptionToken) {
             myExternalApi.cancel(subscriptionToken);
        }
    })
    // In this example myExternalApi may throw.
    try {
        subscriptionToken = myExternalApi.request((value, error) => {
            if (error) {
                sink(Throw(error));
                return;
            }
            sink(Push(value));
            sink(End);
        });
    } catch (error) {
        sink(Throw(error));
    }
});
```

<b>See Also</b>

- <code>[Disposable](..\/01-api-disposable\/00-Disposable.md#Disposable)</code>
- <code>[Event](..\/02-api-event\/00-Event.md#Event)</code>
- <code>[Sink](02-Sink.md#Sink)</code>
- <code>[Subject](..\/05-api-subject\/00-Subject.md#Subject)</code>

### <a name="Source-Interface"></a><code>Source - Interface</code>

<b>Signature - [source.ts#L427](..\/..\/packages\/core\/src\/source.ts#L427)</b>

<pre>interface Source&lt;T&gt; {<br>    (sink: <a href="02-Sink.md#Sink-Interface">Sink</a>&lt;T&gt;): void<br>}</pre><br>

| [Previous \(End\)](..\/02-api-event\/03-End.md#readme) |
| --- |

<div align="right">

| [Next \(isSource\)](01-isSource.md#readme) |
| --- |
</div>
